"""
KSTAR+ Control Tokens (C)

The 4th irreducible memory class: authority to execute.
Non-derivable, exact, time-sensitive, non-compressible.

Control tokens are the bridge between thought and action - they represent
the "gate" that authorizes the movement from reasoning to execution.

Key characteristics:
- Non-derivable: Cannot be inferred from situation, task, or knowledge
- Exact and opaque: Must be precise, functions as identifier not relation
- Time-sensitive: Must be valid at moment of execution
- Non-compressible: Cannot be baked into model weights
"""

from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from typing import Any, Dict, List, Optional
from uuid import uuid4
import hashlib
import json


class TokenType(str, Enum):
    """Types of control tokens across domains"""
    # Digital credentials
    API_KEY = "api_key"
    OAUTH_TOKEN = "oauth"
    SESSION_TOKEN = "session"
    PASSWORD_HASH = "password"

    # File system
    FILE_PATH = "file_path"
    INODE = "inode"
    PERMISSION_BITS = "permission"

    # Skill/capability system
    SKILL_ID = "skill_id"
    CAPABILITY_HANDLE = "capability"
    SIGNED_MANIFEST = "manifest"
    MCP_TOOL_REF = "mcp_tool"

    # Human identity
    PHONE_NUMBER = "phone"
    EMAIL = "email"
    BIOMETRIC_HASH = "biometric"
    BADGE_ID = "badge"

    # Agentic
    FUNCTION_POINTER = "function_ptr"
    AGENT_URI = "agent_uri"
    CHANNEL_BINDING = "channel_binding"


class TokenScope(str, Enum):
    """Scope of access granted by token"""
    READ = "read"
    WRITE = "write"
    EXECUTE = "execute"
    ADMIN = "admin"
    DELETE = "delete"
    ALL = "*"


class ProvenanceMethod(str, Enum):
    """How the token was obtained"""
    ISSUED = "issued"           # Directly issued by authority
    DELEGATED = "delegated"     # Delegated from another principal
    DISCOVERED = "discovered"   # Found through discovery protocol
    USER_PROVIDED = "user_provided"  # Provided by user
    GENERATED = "generated"     # Generated by this agent
    ROTATED = "rotated"         # Rotated from previous token


class ConsumptionMode(str, Enum):
    """How the token can be used"""
    REUSABLE = "reusable"       # Can be used multiple times
    SINGLE_USE = "single_use"   # One-time use only
    COUNTED = "counted"         # Limited number of uses
    TIME_LIMITED = "time_limited"  # Valid for time window only


@dataclass
class TokenProvenance:
    """How was this token obtained?"""
    method: ProvenanceMethod
    source: str                              # Issuer URI or principal ID
    issued_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    attestation: Optional[str] = None        # Signed proof of origin
    delegation_chain: List[str] = field(default_factory=list)  # Chain of custody
    notes: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "method": self.method.value,
            "source": self.source,
            "issued_at": self.issued_at.isoformat(),
            "attestation": self.attestation,
            "delegation_chain": self.delegation_chain,
            "notes": self.notes
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "TokenProvenance":
        return cls(
            method=ProvenanceMethod(data["method"]),
            source=data["source"],
            issued_at=datetime.fromisoformat(data["issued_at"]) if data.get("issued_at") else datetime.now(timezone.utc),
            attestation=data.get("attestation"),
            delegation_chain=data.get("delegation_chain", []),
            notes=data.get("notes")
        )


@dataclass
class TokenUsage:
    """Record of token usage"""
    used_at: datetime
    action_id: str                  # Message or action ID
    action_type: str                # What action was performed
    target: str                     # What resource was accessed
    success: bool
    error_message: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "used_at": self.used_at.isoformat(),
            "action_id": self.action_id,
            "action_type": self.action_type,
            "target": self.target,
            "success": self.success,
            "error_message": self.error_message
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "TokenUsage":
        return cls(
            used_at=datetime.fromisoformat(data["used_at"]),
            action_id=data["action_id"],
            action_type=data["action_type"],
            target=data["target"],
            success=data["success"],
            error_message=data.get("error_message")
        )


@dataclass
class ControlToken:
    """
    KSTAR+ Control Token (C)

    The irreducible 4th memory class: authority to execute.
    This is the "gate" between thought and action.

    Attributes:
        token_id: Unique identifier (URN format)
        token_type: Type of control token
        key: The lookup key (what you search by)
        value_hash: Hash of the actual value (never store raw secrets)
        scopes: What permissions this token grants
        binding_target: What resource/capability this unlocks
        provenance: How the token was obtained
        validity: Time window of validity
        consumption: How the token can be used
    """
    # Identity
    token_id: str = field(default_factory=lambda: f"urn:token:{uuid4()}")
    token_type: TokenType = TokenType.API_KEY

    # Key-Value (the KEY is searchable, VALUE is protected)
    key: str = ""                            # The lookup key (e.g., "anthropic", "whatsapp:+1234567890")
    value_hash: str = ""                     # SHA-256 of actual value
    value_encrypted: Optional[bytes] = None  # Encrypted value (optional, for retrieval)

    # Scope: What capability is granted?
    scopes: List[TokenScope] = field(default_factory=lambda: [TokenScope.READ])
    binding_target: str = ""                 # What this unlocks (e.g., "claude-sonnet-4", "mcp__tool__xyz")

    # Validity: When is it valid?
    valid_from: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    valid_until: Optional[datetime] = None
    is_revoked: bool = False
    revoked_at: Optional[datetime] = None
    revoked_by: Optional[str] = None
    revocation_reason: Optional[str] = None

    # Provenance: How was it obtained?
    provenance: Optional[TokenProvenance] = None

    # Consumption
    consumption_mode: ConsumptionMode = ConsumptionMode.REUSABLE
    remaining_uses: Optional[int] = None
    use_count: int = 0
    last_used_at: Optional[datetime] = None

    # Metadata
    metadata: Dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))

    # Lineage tracking (for delegation chains)
    parent_token_id: Optional[str] = None    # If delegated from another token
    child_token_ids: List[str] = field(default_factory=list)  # Tokens derived from this

    # Principal binding (who is authorized to use this token)
    principal_id: Optional[str] = None       # Primary principal URN that owns this token
    authorized_principals: List[str] = field(default_factory=list)  # Additional authorized principals

    def is_valid(self) -> bool:
        """Check if token is currently valid"""
        now = datetime.now(timezone.utc)

        if self.is_revoked:
            return False

        if now < self.valid_from:
            return False

        if self.valid_until and now > self.valid_until:
            return False

        if self.consumption_mode == ConsumptionMode.SINGLE_USE and self.use_count > 0:
            return False

        if self.consumption_mode == ConsumptionMode.COUNTED and self.remaining_uses is not None:
            if self.remaining_uses <= 0:
                return False

        return True

    def record_usage(self, action_id: str, action_type: str, target: str, success: bool, error: str = None):
        """Record that this token was used"""
        self.use_count += 1
        self.last_used_at = datetime.now(timezone.utc)
        self.updated_at = datetime.now(timezone.utc)

        if self.remaining_uses is not None:
            self.remaining_uses -= 1

    def revoke(self, by: str, reason: str = None):
        """Revoke this token"""
        self.is_revoked = True
        self.revoked_at = datetime.now(timezone.utc)
        self.revoked_by = by
        self.revocation_reason = reason
        self.updated_at = datetime.now(timezone.utc)

    def verify_value(self, value: str) -> bool:
        """Verify a value against stored hash"""
        computed_hash = hashlib.sha256(value.encode()).hexdigest()
        return computed_hash == self.value_hash

    def is_authorized_principal(self, principal_id: str) -> bool:
        """
        Check if a principal is authorized to use this token.

        A principal is authorized if:
        1. They are the owner (self.principal_id)
        2. They are in the authorized_principals list
        3. No principal restrictions are set (principal_id is None)

        Args:
            principal_id: The principal URN to check

        Returns:
            True if the principal is authorized
        """
        # If no principal restriction, token is usable by anyone with the value
        if self.principal_id is None and not self.authorized_principals:
            return True

        # Check if owner
        if self.principal_id == principal_id:
            return True

        # Check if in authorized list
        if principal_id in self.authorized_principals:
            return True

        return False

    @staticmethod
    def hash_value(value: str) -> str:
        """Hash a token value"""
        return hashlib.sha256(value.encode()).hexdigest()

    def to_dict(self) -> Dict[str, Any]:
        """Serialize to dictionary (safe for storage)"""
        return {
            "token_id": self.token_id,
            "token_type": self.token_type.value,
            "key": self.key,
            "value_hash": self.value_hash,
            # Note: value_encrypted NOT included for security
            "scopes": [s.value for s in self.scopes],
            "binding_target": self.binding_target,
            "valid_from": self.valid_from.isoformat(),
            "valid_until": self.valid_until.isoformat() if self.valid_until else None,
            "is_revoked": self.is_revoked,
            "revoked_at": self.revoked_at.isoformat() if self.revoked_at else None,
            "revoked_by": self.revoked_by,
            "revocation_reason": self.revocation_reason,
            "provenance": self.provenance.to_dict() if self.provenance else None,
            "consumption_mode": self.consumption_mode.value,
            "remaining_uses": self.remaining_uses,
            "use_count": self.use_count,
            "last_used_at": self.last_used_at.isoformat() if self.last_used_at else None,
            "metadata": self.metadata,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "parent_token_id": self.parent_token_id,
            "child_token_ids": self.child_token_ids,
            "principal_id": self.principal_id,
            "authorized_principals": self.authorized_principals,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ControlToken":
        """Deserialize from dictionary"""
        return cls(
            token_id=data["token_id"],
            token_type=TokenType(data["token_type"]),
            key=data["key"],
            value_hash=data["value_hash"],
            scopes=[TokenScope(s) for s in data.get("scopes", ["read"])],
            binding_target=data.get("binding_target", ""),
            valid_from=datetime.fromisoformat(data["valid_from"]) if data.get("valid_from") else datetime.now(timezone.utc),
            valid_until=datetime.fromisoformat(data["valid_until"]) if data.get("valid_until") else None,
            is_revoked=data.get("is_revoked", False),
            revoked_at=datetime.fromisoformat(data["revoked_at"]) if data.get("revoked_at") else None,
            revoked_by=data.get("revoked_by"),
            revocation_reason=data.get("revocation_reason"),
            provenance=TokenProvenance.from_dict(data["provenance"]) if data.get("provenance") else None,
            consumption_mode=ConsumptionMode(data.get("consumption_mode", "reusable")),
            remaining_uses=data.get("remaining_uses"),
            use_count=data.get("use_count", 0),
            last_used_at=datetime.fromisoformat(data["last_used_at"]) if data.get("last_used_at") else None,
            metadata=data.get("metadata", {}),
            created_at=datetime.fromisoformat(data["created_at"]) if data.get("created_at") else datetime.now(timezone.utc),
            updated_at=datetime.fromisoformat(data["updated_at"]) if data.get("updated_at") else datetime.now(timezone.utc),
            parent_token_id=data.get("parent_token_id"),
            child_token_ids=data.get("child_token_ids", []),
            principal_id=data.get("principal_id"),
            authorized_principals=data.get("authorized_principals", []),
        )

    @classmethod
    def create(
        cls,
        key: str,
        value: str,
        token_type: TokenType,
        binding_target: str,
        scopes: List[TokenScope] = None,
        provenance_source: str = "system",
        provenance_method: ProvenanceMethod = ProvenanceMethod.GENERATED,
        valid_days: int = None,
        metadata: Dict[str, Any] = None,
        principal_id: str = None,
        authorized_principals: List[str] = None
    ) -> "ControlToken":
        """
        Factory method to create a new control token.

        Args:
            key: The lookup key (e.g., "anthropic", "whatsapp:+1234567890")
            value: The actual secret value (will be hashed)
            token_type: Type of token
            binding_target: What this token unlocks
            scopes: Permissions granted
            provenance_source: Who/what issued this token
            provenance_method: How it was obtained
            valid_days: Number of days until expiry (None = never)
            metadata: Additional metadata
            principal_id: The principal URN that owns this token
            authorized_principals: Additional principals authorized to use this token

        Returns:
            New ControlToken instance
        """
        now = datetime.now(timezone.utc)

        return cls(
            token_id=f"urn:token:{token_type.value}:{hashlib.sha256(key.encode()).hexdigest()[:12]}",
            token_type=token_type,
            key=key,
            value_hash=cls.hash_value(value),
            scopes=scopes or [TokenScope.READ],
            binding_target=binding_target,
            valid_from=now,
            valid_until=now.replace(day=now.day + valid_days) if valid_days else None,
            provenance=TokenProvenance(
                method=provenance_method,
                source=provenance_source,
                issued_at=now
            ),
            metadata=metadata or {},
            created_at=now,
            updated_at=now,
            principal_id=principal_id,
            authorized_principals=authorized_principals or [],
        )
